const fs = require('fs');
const path = require('path');
const providerManager = require('../providers/providerManager.cjs');
const cfg = require('../../../config/embeddings.config.cjs');

// CRITICAL FIX: Use process.cwd() for consistent paths
const EMB_DIR = path.join(process.cwd(), 'data', 'storage', 'embeddings');

// Ensure embeddings directory exists
if (!fs.existsSync(EMB_DIR)) {
  fs.mkdirSync(EMB_DIR, { recursive: true });
  console.log(`[embeddings] Created embeddings directory: ${EMB_DIR}`);
}

function cosineSim(a, b) {
  let dot = 0, na = 0, nb = 0;
  const n = Math.min(a.length, b.length);
  for (let i = 0; i < n; i++) { dot += a[i]*b[i]; na += a[i]*a[i]; nb += b[i]*b[i]; }
  return dot / (Math.sqrt(na) * Math.sqrt(nb) + 1e-9);
}

async function indexVideo(videoId, chunks, onProgress = () => {}) {
  console.log(`[embeddings] Starting indexing for video ${videoId} with ${chunks.length} chunks`);
  const out = { videoId, createdAt: Date.now(), vectors: [] };
  let successCount = 0;
  let errorCount = 0;
  const startTime = Date.now();
  const TIMEOUT_MS = 45000; // 45 second timeout
  
  for (let i = 0; i < chunks.length; i++) {
    // Check timeout
    if (Date.now() - startTime > TIMEOUT_MS) {
      console.warn(`[embeddings] Timeout after ${TIMEOUT_MS}ms, stopping at chunk ${i}/${chunks.length}`);
      break;
    }
    
    try {
      console.log(`[embeddings] Processing chunk ${i+1}/${chunks.length}: ${chunks[i].chunkId}`);
      
      // Add timeout to individual embedding calls
      const embeddingPromise = providerManager.embed(chunks[i].text);
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Embedding timeout')), 10000)
      );
      
      const embeddingResult = await Promise.race([embeddingPromise, timeoutPromise]);
      
      // Handle different response formats from providers
      let vector = null;
      if (Array.isArray(embeddingResult)) {
        vector = embeddingResult;
      } else if (embeddingResult && embeddingResult.embedding && Array.isArray(embeddingResult.embedding)) {
        vector = embeddingResult.embedding;
      } else if (embeddingResult && Array.isArray(embeddingResult.data)) {
        vector = embeddingResult.data;
      }
      
      // Validate vector
      if (!vector || !Array.isArray(vector) || vector.length === 0) {
        console.error(`[embeddings] Invalid vector for chunk ${chunks[i].chunkId}:`, typeof embeddingResult, embeddingResult);
        errorCount++;
        continue;
      }
      
      console.log(`[embeddings] Generated vector of length ${vector.length} for chunk ${chunks[i].chunkId}`);
      out.vectors.push({
        chunkId: chunks[i].chunkId,
        start: chunks[i].start,
        end: chunks[i].end,
        vector: vector,
        excerpt: chunks[i].text.slice(0, 200)
      });
      successCount++;
    } catch (error) {
      console.error(`[embeddings] Error processing chunk ${chunks[i].chunkId}:`, error.message);
      errorCount++;
    }
    
    onProgress((i + 1) / chunks.length);
  }
  
  console.log(`[embeddings] Indexing complete for ${videoId}: ${successCount} successful, ${errorCount} errors`);
  
  // Only save if we have at least some successful embeddings
  if (successCount > 0) {
    const file = path.join(EMB_DIR, `${videoId}.json`);
    // Ensure directory exists before writing
    if (!fs.existsSync(EMB_DIR)) {
      fs.mkdirSync(EMB_DIR, { recursive: true });
      console.log(`[embeddings] Created embeddings directory: ${EMB_DIR}`);
    }
    fs.writeFileSync(file, JSON.stringify(out, null, 2));
    console.log(`[embeddings] Saved embeddings to ${file}`);
  } else {
    console.error(`[embeddings] No successful embeddings generated for ${videoId}, not saving file`);
    throw new Error(`Failed to generate any embeddings for video ${videoId}`);
  }
}

function loadIndex(videoId) {
  const file = path.join(EMB_DIR, `${videoId}.json`);
  if (!fs.existsSync(file)) return null;
  return JSON.parse(fs.readFileSync(file, 'utf-8'));
}

function search(videoId, queryVector, options = {}) {
  const topK = options.topK || cfg.topK;
  console.log(`[embeddings] search() - loading index for ${videoId}...`);
  
  const idx = loadIndex(videoId);
  
  if (!idx) {
    console.error(`[embeddings] âŒ INDEX MISSING: Cannot search without embeddings index for video ${videoId}!`);
    console.log(`[embeddings] ðŸ’¡ Suggestion: Ensure embeddings are generated by checking transcript processing pipeline`);
    return [];
  }
  
  console.log(`[embeddings] âœ… Index loaded: ${idx.vectors?.length || 0} vectors found`);
  
  // Validate index structure
  if (!idx.vectors || !Array.isArray(idx.vectors)) {
    console.error(`[embeddings] âŒ Invalid index structure for ${videoId}: missing or invalid vectors array`);
    return [];
  }
  
  // Check for empty vectors
  const emptyVectorCount = idx.vectors.filter(v => !v.vector || !Array.isArray(v.vector) || v.vector.length === 0).length;
  if (emptyVectorCount > 0) {
    console.warn(`[embeddings] âš ï¸ Found ${emptyVectorCount} empty vectors in index for ${videoId}`);
    console.log(`[embeddings] ðŸ’¡ Suggestion: Regenerate embeddings for this video to fix empty vectors`);
  }
  
  // Filter out vectors with valid data
  const validVectors = idx.vectors.filter(v => v.vector && Array.isArray(v.vector) && v.vector.length > 0);
  console.log(`[embeddings] ðŸ” Scoring ${validVectors.length} valid vectors with cosine similarity...`);
  
  if (validVectors.length === 0) {
    console.error(`[embeddings] âŒ No valid vectors found for search in ${videoId}`);
    console.log(`[embeddings] ðŸ’¡ All vectors appear to be empty or invalid. Regeneration required.`);
    return [];
  }
  
  // Validate query vector
  if (!queryVector || !Array.isArray(queryVector) || queryVector.length === 0) {
    console.error(`[embeddings] âŒ Invalid query vector provided for search`);
    return [];
  }
  
  try {
    const scored = validVectors
      .map((row) => {
        try {
          return {
            ...row,
            score: cosineSim(row.vector, queryVector),
            text: row.excerpt || row.text || ''
          };
        } catch (scoreError) {
          console.warn(`[embeddings] Error scoring vector for chunk ${row.chunkId}:`, scoreError.message);
          return null;
        }
      })
      .filter(result => result !== null && !isNaN(result.score))
      .sort((a, b) => b.score - a.score)
      .slice(0, topK);
    
    if (scored.length === 0) {
      console.warn(`[embeddings] âš ï¸ No valid scores generated for search in ${videoId}`);
      return [];
    }
    
    console.log(`[embeddings] âœ… Top ${scored.length} results (scores: ${scored.slice(0, 3).map(r => r.score?.toFixed?.(4)).join(', ')})`);
    
    // Check if scores are meaningful (not all zeros or very low)
    const maxScore = scored[0]?.score || 0;
    if (maxScore < 0.01) {
      console.warn(`[embeddings] âš ï¸ Very low similarity scores detected (max: ${maxScore.toFixed(4)})`);
      console.log(`[embeddings] ðŸ’¡ This might indicate poor embedding quality or mismatched vector dimensions`);
    }
    
    return scored;
  } catch (searchError) {
    console.error(`[embeddings] âŒ Critical error during search for ${videoId}:`, searchError.message);
    console.error(`[embeddings] Stack trace:`, searchError.stack);
    return [];
  }
}

module.exports = { indexVideo, loadIndex, search };